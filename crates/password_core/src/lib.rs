pub mod crypto;
pub mod data_types; // Make sure this is present if you use data_types.rs
pub mod error;

// Re-export constants and types from crypto for easier access
pub use crypto::{SALT_LEN, NONCE_LEN, KEY_LEN, EncryptionKey};

#[cfg(test)]
mod tests {
    use super::*; // Now super includes the re-exported items
    use crate::crypto::{generate_random_bytes, derive_key_from_password, encrypt, decrypt}; // Individual functions still needed

    #[test]
    fn test_generate_random_bytes() {
        let len = 32;
        let bytes = generate_random_bytes(len);
        assert_eq!(bytes.len(), len);
        // It's highly unlikely that all bytes are zero for a cryptographically secure RNG
        assert!(!bytes.iter().all(|&b| b == 0), "Generated bytes should not be all zeros");

        let len_small = 5;
        let bytes_small = generate_random_bytes(len_small);
        assert_eq!(bytes_small.len(), len_small);
    }

    #[test]
    fn test_derive_key_from_password_new_salt() {
        let password = b"my_master_password";
        let (key1, salt1) = derive_key_from_password(password, None).unwrap();
        assert_eq!(key1.as_slice().len(), KEY_LEN);
        assert_eq!(salt1.len(), SALT_LEN);

        let (key2, salt2) = derive_key_from_password(password, None).unwrap();
        // With `None` for salt, a new random salt should be generated each time
        assert_ne!(salt1, salt2, "Different salts should be generated when None is provided");
        assert_ne!(key1, key2, "Different keys should be derived with different salts");
    }

    #[test]
    fn test_derive_key_from_password_fixed_salt() {
        let password = b"my_master_password";
        let fixed_salt = generate_random_bytes(SALT_LEN);

        let (key1, _) = derive_key_from_password(password, Some(&fixed_salt)).unwrap();
        let (key2, _) = derive_key_from_password(password, Some(&fixed_salt)).unwrap();

        // With a fixed salt, the same key should be derived
        assert_eq!(key1, key2, "Same key should be derived with the same password and fixed salt");
    }

    #[test]
    fn test_encrypt_decrypt_cycle() {
        let password = b"strong_master_password";
        let (key, _salt) = derive_key_from_password(password, None).unwrap();

        let plaintext = b"This is a secret message that needs to be protected.";
        let (ciphertext, nonce) = encrypt(&key, plaintext).unwrap();

        assert_ne!(plaintext.to_vec(), ciphertext, "Ciphertext should not be equal to plaintext");
        assert_eq!(nonce.len(), NONCE_LEN, "Nonce should have correct length");

        let decrypted_text = decrypt(&key, &ciphertext, &nonce).unwrap();
        assert_eq!(plaintext.to_vec(), decrypted_text, "Decrypted text should match original plaintext");

        // Test with empty plaintext
        let empty_plaintext = b"";
        let (empty_ciphertext, empty_nonce) = encrypt(&key, empty_plaintext).unwrap();
        assert!(empty_ciphertext.len() > 0, "Empty plaintext should still produce non-empty ciphertext (due to tag)");
        assert_eq!(empty_nonce.len(), NONCE_LEN, "Nonce for empty plaintext should have correct length");
        let decrypted_empty_text = decrypt(&key, &empty_ciphertext, &empty_nonce).unwrap();
        assert_eq!(empty_plaintext.to_vec(), decrypted_empty_text, "Decrypted empty text should match original empty plaintext");
    }
}