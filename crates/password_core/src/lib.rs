// crates/password_core/src/lib.rs

pub mod crypto;
pub mod data_types;
pub mod error;
pub mod settings_manager; // Declare the settings_manager module

// Re-export constants and types from crypto for easier access
pub use crypto::{SALT_LEN, NONCE_LEN, KEY_LEN, EncryptionKey}; // EncryptionKey is now data_types::PasswordBytes
pub use error::PasswordManagerError; // Re-export your custom error type
pub use settings_manager::{AppConfig, AppUserProfile}; // FIX: Changed AppSettings to AppConfig

#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::{generate_random_bytes, derive_key_from_password, encrypt, decrypt};

    #[test]
    fn test_generate_random_bytes() {
        let len = 32;
        let bytes = generate_random_bytes(len);
        assert_eq!(bytes.len(), len);
        assert!(!bytes.iter().all(|&b| b == 0), "Generated bytes should not be all zeros");

        let len_small = 5;
        let bytes_small = generate_random_bytes(len_small);
        assert_eq!(bytes_small.len(), len_small);
    }

    #[test]
    fn test_derive_key_from_password_new_salt() {
        let password = b"my_master_password";
        let (key1, salt1) = derive_key_from_password(password, None).unwrap();
        assert_eq!(key1.0.len(), KEY_LEN);
        assert_eq!(salt1.len(), SALT_LEN);

        let (key2, salt2) = derive_key_from_password(password, None).unwrap();
        assert_ne!(salt1, salt2, "Different salts should be generated when None is provided");
        assert_ne!(key1.0, key2.0, "Different keys should be derived with different salts");
    }

    #[test]
    fn test_derive_key_from_password_fixed_salt() {
        let password = b"my_master_password";
        let fixed_salt = generate_random_bytes(SALT_LEN);

        let (key1, _) = derive_key_from_password(password, Some(&fixed_salt)).unwrap();
        let (key2, _) = derive_key_from_password(password, Some(&fixed_salt)).unwrap();

        assert_eq!(key1.0, key2.0, "Same key should be derived with the same password and fixed salt");
    }

    #[test]
    fn test_encrypt_decrypt_cycle() {
        let password = b"strong_master_password";
        let (key, _salt) = derive_key_from_password(password, None).unwrap();

        let plaintext = b"This is a secret message that needs to be protected.";
        let (ciphertext, nonce) = encrypt(&key, plaintext).unwrap();

        assert_ne!(plaintext.to_vec(), ciphertext, "Ciphertext should not be equal to plaintext");
        assert_eq!(nonce.len(), NONCE_LEN, "Nonce should have correct length");

        let decrypted_text = decrypt(&key, &ciphertext, &nonce).unwrap();
        assert_eq!(plaintext.to_vec(), decrypted_text, "Decrypted text should match original plaintext");

        let empty_plaintext = b"";
        let (empty_ciphertext, empty_nonce) = encrypt(&key, empty_plaintext).unwrap();
        assert!(empty_ciphertext.len() > 0, "Empty plaintext should still produce non-empty ciphertext (due to tag)");
        assert_eq!(empty_nonce.len(), NONCE_LEN, "Nonce for empty plaintext should have correct length");
        let decrypted_empty_text = decrypt(&key, &empty_ciphertext, &empty_nonce).unwrap();
        assert_eq!(empty_plaintext.to_vec(), decrypted_empty_text, "Decrypted empty text should match original empty plaintext");
    }
}