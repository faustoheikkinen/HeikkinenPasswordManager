#[cfg(test)]
mod tests {
    use super::*;
    use crate::crypto::{generate_random_bytes, derive_key_from_password, encrypt, decrypt, KEY_LEN, SALT_LEN, NONCE_LEN};

    #[test]
    fn test_generate_random_bytes() {
        let len = 32;
        let bytes = generate_random_bytes(len);
        assert_eq!(bytes.len(), len);
        // It's highly unlikely that all bytes are zero for a cryptographically secure RNG
        assert!(!bytes.iter().all(|&b| b == 0), "Generated bytes should not be all zeros");

        let len_small = 5;
        let bytes_small = generate_random_bytes(len_small);
        assert_eq!(bytes_small.len(), len_small);
    }

    #[test]
    fn test_derive_key_from_password_new_salt() {
        let password = b"my_master_password";
        let (key1, salt1) = derive_key_from_password(password, None).unwrap();
        assert_eq!(key1.as_slice().len(), KEY_LEN);
        assert_eq!(salt1.len(), SALT_LEN);

        let (key2, salt2) = derive_key_from_password(password, None).unwrap();
        // With `None` for salt, a new random salt should be generated each time
        assert_ne!(salt1, salt2, "Different salts should be generated when None is provided");
        assert_ne!(key1, key2, "Different keys should be derived with different salts");
    }

    #[test]
    fn test_derive_key_from_password_fixed_salt() {
        let password = b"my_master_password";
        let fixed_salt = generate_random_bytes(SALT_LEN);

        let (key1, _) = derive_key_from_password(password, Some(&fixed_salt)).unwrap();
        let (key2, _) = derive_key_from_password(password, Some(&fixed_salt)).unwrap();

        // With a fixed salt, the same key should be derived
        assert_eq!(key1, key2, "Same key should be derived with the same password and fixed salt");
    }

    #[test]
    fn test_derive_key_from_password_empty_password() {
        let password = b"";
        let salt = generate_random_bytes(SALT_LEN);
        let result = derive_key_from_password(password, Some(&salt));
        // Argon2 should still work with an empty password, just not recommended for security
        assert!(result.is_ok(), "Empty password should still result in a key derivation, though not secure");
    }

    #[test]
    fn test_derive_key_from_password_invalid_salt_len() {
        let password = b"test";
        let invalid_salt = vec![1, 2, 3]; // Incorrect length
        let result = derive_key_from_password(password, Some(&invalid_salt));
        assert!(result.is_err());
        match result.unwrap_err() {
            PasswordManagerError::Other(msg) => assert!(msg.contains("Provided salt must be exactly")),
            _ => panic!("Expected Other error for invalid salt length"),
        }
    }

    #[test]
    fn test_encrypt_decrypt_cycle() {
        let password = b"strong_master_password";
        let (key, salt) = derive_key_from_password(password, None).unwrap();

        let plaintext = b"This is a secret message that needs to be protected.";
        let (ciphertext, nonce) = encrypt(&key, plaintext).unwrap();

        assert_ne!(plaintext, ciphertext, "Ciphertext should not be equal to plaintext");
        assert_eq!(nonce.len(), NONCE_LEN, "Nonce should have correct length");

        let decrypted_text = decrypt(&key, &ciphertext, &nonce).unwrap();
        assert_eq!(plaintext.to_vec(), decrypted_text, "Decrypted text should match original plaintext");

        // Test with empty plaintext
        let empty_plaintext = b"";
        let (empty_ciphertext, empty_nonce) = encrypt(&key, empty_plaintext).unwrap();
        assert!(empty_ciphertext.len() > 0, "Empty plaintext should still produce non-empty ciphertext (due to tag)");
        assert_eq!(empty_nonce.len(), NONCE_LEN, "Nonce for empty plaintext should have correct length");
        let decrypted_empty_text = decrypt(&key, &empty_ciphertext, &empty_nonce).unwrap();
        assert_eq!(empty_plaintext.to_vec(), decrypted_empty_text, "Decrypted empty text should match original empty plaintext");
    }

    #[test]
    fn test_decrypt_with_incorrect_key() {
        let correct_password = b"correct_password";
        let wrong_password = b"wrong_password";

        let (correct_key, salt) = derive_key_from_password(correct_password, None).unwrap();
        let (wrong_key, _) = derive_key_from_password(wrong_password, Some(&salt)).unwrap(); // Use same salt to ensure key difference

        let plaintext = b"Sensitive data.";
        let (ciphertext, nonce) = encrypt(&correct_key, plaintext).unwrap();

        let result = decrypt(&wrong_key, &ciphertext, &nonce);
        assert!(result.is_err(), "Decryption should fail with incorrect key");
        assert_eq!(result.unwrap_err(), PasswordManagerError::DecryptionFailed);
    }

    #[test]
    fn test_decrypt_with_incorrect_nonce() {
        let password = b"password123";
        let (key, _) = derive_key_from_password(password, None).unwrap();

        let plaintext = b"Another secret.";
        let (ciphertext, _correct_nonce) = encrypt(&key, plaintext).unwrap();

        let wrong_nonce = generate_random_bytes(NONCE_LEN); // A randomly generated, incorrect nonce

        let result = decrypt(&key, &ciphertext, &wrong_nonce);
        assert!(result.is_err(), "Decryption should fail with incorrect nonce");
        assert_eq!(result.unwrap_err(), PasswordManagerError::DecryptionFailed);
    }

    #[test]
    fn test_decrypt_with_tampered_ciphertext() {
        let password = b"password_for_tampering";
        let (key, _) = derive_key_from_password(password, None).unwrap();

        let plaintext = b"Original message.";
        let (mut ciphertext, nonce) = encrypt(&key, plaintext).unwrap();

        // Tamper with the ciphertext (e.g., flip a bit)
        if !ciphertext.is_empty() {
            ciphertext[0] = ciphertext[0].wrapping_add(1); // Introduce a change
        } else {
            // If ciphertext is empty, we can't tamper this way, might need to adjust test
            // (e.g., ensure plaintext is always non-empty for this specific test case)
            return;
        }


        let result = decrypt(&key, &ciphertext, &nonce);
        assert!(result.is_err(), "Decryption should fail with tampered ciphertext");
        assert_eq!(result.unwrap_err(), PasswordManagerError::DecryptionFailed);
    }

    #[test]
    fn test_decrypt_with_invalid_nonce_length() {
        let password = b"test_pass";
        let (key, _) = derive_key_from_password(password, None).unwrap();
        let plaintext = b"some data";
        let (ciphertext, _nonce) = encrypt(&key, plaintext).unwrap();

        let short_nonce = vec![1, 2, 3]; // Too short
        let result = decrypt(&key, &ciphertext, &short_nonce);
        assert!(result.is_err());
        match result.unwrap_err() {
            PasswordManagerError::Other(msg) => assert!(msg.contains("Invalid nonce length")),
            _ => panic!("Expected Other error for invalid nonce length"),
        }

        let long_nonce = vec![1; NONCE_LEN + 1]; // Too long
        let result = decrypt(&key, &ciphertext, &long_nonce);
        assert!(result.is_err());
        match result.unwrap_err() {
            PasswordManagerError::Other(msg) => assert!(msg.contains("Invalid nonce length")),
            _ => panic!("Expected Other error for invalid nonce length"),
        }
    }
}